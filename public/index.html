<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modern Chat App</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="/socket.io/socket.io.js"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    animation: {
                        'fade-in': 'fadeIn 0.3s ease-in-out',
                        'slide-up': 'slideUp 0.3s ease-out',
                        'pulse-dot': 'pulseDot 1.4s infinite ease-in-out',
                        'bounce-call': 'bounceCall 1s infinite'
                    },
                    keyframes: {
                        fadeIn: {
                            '0%': { opacity: '0' },
                            '100%': { opacity: '1' }
                        },
                        slideUp: {
                            '0%': { transform: 'translateY(10px)', opacity: '0' },
                            '100%': { transform: 'translateY(0)', opacity: '1' }
                        },
                        pulseDot: {
                            '0%, 80%, 100%': { transform: 'scale(0)' },
                            '40%': { transform: 'scale(1)' }
                        },
                        bounceCall: {
                            '0%, 20%, 50%, 80%, 100%': { transform: 'translateY(0)' },
                            '40%': { transform: 'translateY(-10px)' },
                            '60%': { transform: 'translateY(-5px)' }
                        }
                    }
                }
            }
        }
    </script>
</head>
<body class="bg-gray-50 h-screen flex items-center justify-center p-4">
    <!-- Username Modal -->
    <div id="usernameModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div class="bg-white rounded-2xl p-8 shadow-2xl max-w-md w-full mx-4 animate-slide-up">
            <div class="text-center mb-6">
                <div class="w-16 h-16 bg-gradient-to-r from-blue-500 to-purple-600 rounded-full mx-auto mb-4 flex items-center justify-center">
                    <svg class="w-8 h-8 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z"></path>
                    </svg>
                </div>
                <h2 class="text-2xl font-bold text-gray-800 mb-2">Join Chat</h2>
                <p class="text-gray-600">Enter your name and allow microphone access for voice calls</p>
            </div>
            <form id="usernameForm">
                <input type="text" id="usernameInput" placeholder="Your name..."
                       class="w-full px-4 py-3 border border-gray-300 rounded-xl focus:ring-2 focus:ring-blue-500 focus:border-transparent outline-none transition-all duration-200 mb-4">
                <button type="submit"
                        class="w-full bg-gradient-to-r from-blue-500 to-purple-600 text-white py-3 rounded-xl font-semibold hover:from-blue-600 hover:to-purple-700 transition-all duration-200 transform hover:scale-[1.02]">
                    Start Chatting
                </button>
            </form>
        </div>
    </div>

    <!-- Call Modal -->
    <div id="callModal" class="hidden fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50">
        <div class="bg-white rounded-2xl p-8 shadow-2xl max-w-md w-full mx-4 animate-slide-up">
            <div class="text-center">
                <div id="callStatus" class="mb-6">
                    <div class="w-20 h-20 bg-gradient-to-r from-green-500 to-blue-600 rounded-full mx-auto mb-4 flex items-center justify-center animate-bounce-call">
                        <svg class="w-10 h-10 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 5a2 2 0 012-2h3.28a1 1 0 01.948.684l1.498 4.493a1 1 0 01-.502 1.21l-2.257 1.13a11.042 11.042 0 005.516 5.516l1.13-2.257a1 1 0 011.21-.502l4.493 1.498a1 1 0 01.684.949V19a2 2 0 01-2 2h-1C9.716 21 3 14.284 3 6V5z"></path>
                        </svg>
                    </div>
                    <h3 id="callTitle" class="text-xl font-bold text-gray-800 mb-2">Incoming Call</h3>
                    <p id="callDescription" class="text-gray-600">Someone is calling you...</p>
                </div>
                <div id="callButtons" class="flex space-x-4 justify-center">
                    <button id="acceptCall" class="px-6 py-3 bg-green-500 text-white rounded-xl font-semibold hover:bg-green-600 transition-all duration-200">
                        Accept
                    </button>
                    <button id="rejectCall" class="px-6 py-3 bg-red-500 text-white rounded-xl font-semibold hover:bg-red-600 transition-all duration-200">
                        Decline
                    </button>
                </div>
                <div id="callInProgress" class="hidden">
                    <button id="endCall" class="px-6 py-3 bg-red-500 text-white rounded-xl font-semibold hover:bg-red-600 transition-all duration-200">
                        End Call
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- File Upload Modal -->
    <div id="fileModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div class="bg-white rounded-2xl p-8 shadow-2xl max-w-md w-full mx-4 animate-slide-up">
            <div class="text-center mb-6">
                <div class="w-16 h-16 bg-gradient-to-r from-green-500 to-blue-600 rounded-full mx-auto mb-4 flex items-center justify-center">
                    <svg class="w-8 h-8 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path>
                    </svg>
                </div>
                <h2 class="text-2xl font-bold text-gray-800 mb-2">Upload File</h2>
                <p class="text-gray-600">Select a file to share</p>
            </div>
            <div class="mb-4">
                <input type="file" id="fileInput" class="hidden" accept="image/*,.pdf,.doc,.docx,.txt,.xls,.xlsx">
                <label for="fileInput" class="block w-full p-6 border-2 border-dashed border-gray-300 rounded-xl text-center cursor-pointer hover:border-blue-400 transition-colors duration-200">
                    <svg class="w-8 h-8 text-gray-400 mx-auto mb-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path>
                    </svg>
                    <span class="text-gray-600">Click to select file</span>
                </label>
            </div>
            <div id="filePreview" class="hidden mb-4 p-3 bg-gray-50 rounded-lg">
                <div class="flex items-center">
                    <svg class="w-6 h-6 text-blue-500 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                    </svg>
                    <div>
                        <div id="fileName" class="font-medium text-gray-800"></div>
                        <div id="fileSize" class="text-sm text-gray-500"></div>
                    </div>
                </div>
            </div>
            <div class="flex space-x-4">
                <button id="cancelUpload" class="flex-1 px-4 py-3 border border-gray-300 text-gray-700 rounded-xl font-semibold hover:bg-gray-50 transition-all duration-200">
                    Cancel
                </button>
                <button id="confirmUpload" class="flex-1 px-4 py-3 bg-gradient-to-r from-blue-500 to-purple-600 text-white rounded-xl font-semibold hover:from-blue-600 hover:to-purple-700 transition-all duration-200 disabled:opacity-50" disabled>
                    Send File
                </button>
            </div>
        </div>
    </div>

    <!-- Main Chat Interface -->
    <div id="chatContainer" class="hidden w-full max-w-6xl h-full max-h-[800px] bg-white rounded-2xl shadow-2xl overflow-hidden flex flex-col lg:flex-row">
        <!-- Sidebar -->
        <div class="w-full lg:w-80 bg-gray-900 text-white flex flex-col order-2 lg:order-1">
            <!-- Header -->
            <div class="p-4 lg:p-6 border-b border-gray-700 flex items-center justify-between">
                <div>
                    <h1 class="text-lg lg:text-xl font-bold flex items-center">
                        <div class="w-3 h-3 bg-green-400 rounded-full mr-3 animate-pulse"></div>
                        Customer Care
                    </h1>
                    <p class="text-gray-400 text-xs lg:text-sm mt-1">Real-time messaging</p>
                </div>
                <div class="flex items-center space-x-2">
                    <div id="micStatus" class="w-2 h-2 bg-red-500 rounded-full" title="Microphone status"></div>
                    <button id="callButton" class="p-2 bg-green-500 hover:bg-green-600 rounded-full transition-colors duration-200" title="Make a call">
                        <svg class="w-4 h-4 lg:w-5 lg:h-5 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 5a2 2 0 012-2h3.28a1 1 0 01.948.684l1.498 4.493a1 1 0 01-.502 1.21l-2.257 1.13a11.042 11.042 0 005.516 5.516l1.13-2.257a1 1 0 011.21-.502l4.493 1.498a1 1 0 01.684.949V19a2 2 0 01-2 2h-1C9.716 21 3 14.284 3 6V5z"></path>
                        </svg>
                    </button>
                </div>
            </div>

            <!-- Online Users -->
            <div class="p-4 lg:p-6 flex-1 max-h-40 lg:max-h-none overflow-y-auto">
                <h3 class="text-xs lg:text-sm font-semibold text-gray-400 uppercase tracking-wider mb-4">Online Users</h3>
                <div id="usersList" class="space-y-2">
                    <!-- Users will be populated here -->
                </div>
            </div>

            <!-- User Info -->
            <div class="p-4 lg:p-6 border-t border-gray-700">
                <div class="flex items-center">
                    <div class="w-8 h-8 lg:w-10 lg:h-10 bg-gradient-to-r from-blue-500 to-purple-600 rounded-full flex items-center justify-center mr-3">
                        <span id="userInitial" class="text-white text-sm lg:text-base font-semibold"></span>
                    </div>
                    <div>
                        <div id="currentUsername" class="text-sm lg:text-base font-semibold"></div>
                        <div class="text-xs text-gray-400">Online</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Chat Area -->
        <div class="flex-1 flex flex-col order-1 lg:order-2 h-full">
            <!-- Chat Header -->
            <div class="p-4 lg:p-6 border-b border-gray-200 bg-white">
                <h2 class="text-lg lg:text-xl font-semibold text-gray-800">General Chat</h2>
                <p class="text-gray-500 text-xs lg:text-sm">Share your thoughts with everyone</p>
            </div>

            <!-- Messages Container -->
            <div id="messagesContainer" class="flex-1 overflow-y-auto p-4 lg:p-6 space-y-4 bg-gray-50 min-h-0">
                <!-- Messages will be populated here -->
            </div>

            <!-- Typing Indicator -->
            <div id="typingIndicator" class="hidden px-4 lg:px-6 py-2">
                <div class="flex items-center text-gray-500 text-sm">
                    <div class="flex space-x-1 mr-2">
                        <div class="w-2 h-2 bg-gray-400 rounded-full animate-pulse-dot"></div>
                        <div class="w-2 h-2 bg-gray-400 rounded-full animate-pulse-dot" style="animation-delay: 0.2s"></div>
                        <div class="w-2 h-2 bg-gray-400 rounded-full animate-pulse-dot" style="animation-delay: 0.4s"></div>
                    </div>
                    <span id="typingText">Someone is typing...</span>
                </div>
            </div>

            <!-- Message Input -->
            <div class="p-4 lg:p-6 border-t border-gray-200 bg-white">
                <form id="messageForm" class="flex space-x-2 lg:space-x-4">
                    <button type="button" id="attachButton" class="px-2 lg:px-3 py-3 text-gray-500 hover:text-blue-500 transition-colors duration-200 flex-shrink-0" title="Attach file">
                        <svg class="w-4 h-4 lg:w-5 lg:h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.172 7l-6.586 6.586a2 2 0 102.828 2.828l6.414-6.586a4 4 0 00-5.656-5.656l-6.415 6.585a6 6 0 108.486 8.486L20.5 13"></path>
                        </svg>
                    </button>
                    <input type="text" id="messageInput" placeholder="Type your message..."
                           class="flex-1 px-3 lg:px-4 py-3 border border-gray-300 rounded-xl focus:ring-2 focus:ring-blue-500 focus:border-transparent outline-none transition-all duration-200 text-sm lg:text-base">
                    <button type="submit"
                            class="px-4 lg:px-6 py-3 bg-gradient-to-r from-blue-500 to-purple-600 text-white rounded-xl font-semibold hover:from-blue-600 hover:to-purple-700 transition-all duration-200 transform hover:scale-[1.02] flex items-center flex-shrink-0">
                        <svg class="w-4 h-4 lg:w-5 lg:h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"></path>
                        </svg>
                    </button>
                </form>
            </div>
        </div>
    </div>

    <!-- Audio elements for calls -->
    <audio id="localAudio" autoplay muted></audio>
    <audio id="remoteAudio" autoplay></audio>

    <!-- Ringtone audio elements -->
    <audio id="incomingRingtone" loop preload="auto">
        <source src="data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhCjuAxfTWfzMGHWq+8NiKOgcaaL7t4Z1NEAxOpOHyvmAgCz6PzfHOeCkELnzN8N6PQAkSXrXo45xOEhFHpuLvt2AcCzOExvLWfTE=" type="audio/wav">
    </audio>

    <audio id="outgoingRingtone" loop preload="auto">
        <source src="data:audio/wav;base64,UklGRuICAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YcACAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhCjuAxfTWfzMGHWq+8NiKOgcaaL7t4Z1NEAxOpOHyvmAgCz6PzfHOeCkELnzN8N6PQAkSXrXo45xOEhFHpuLvt2AcCzOExvLWfTE=" type="audio/wav">
    </audio>

    <script>
        const socket = io();
        let currentUser = '';
        let typingTimer;
        let selectedFile = null;
        let currentCallId = null;
        let localStream = null;
        let remoteStream = null;
        let peerConnection = null;
        let connectedUsers = [];
        let currentPeerId = null;
        let callState = 'idle'; // idle, ringing, connecting, connected
        let ringtonePlaying = false;

        // Check socket connection
        socket.on('connect', () => {
            console.log('Connected to server with ID:', socket.id);
        });

        socket.on('disconnect', () => {
            console.log('Disconnected from server');
            // If in a call, end it cleanly
            if (callState !== 'idle') {
                console.log('Socket disconnected during call - ending call');
                endCurrentCall();
                hideCallModal();
                alert('Connection lost. Call ended.');
            }
        });

        socket.on('connect_error', (error) => {
            console.error('Connection error:', error);
            alert('Failed to connect to server. Please refresh the page.');
        });

        // DOM elements
        const usernameModal = document.getElementById('usernameModal');
        const chatContainer = document.getElementById('chatContainer');
        const usernameForm = document.getElementById('usernameForm');
        const usernameInput = document.getElementById('usernameInput');
        const messageForm = document.getElementById('messageForm');
        const messageInput = document.getElementById('messageInput');
        const messagesContainer = document.getElementById('messagesContainer');
        const usersList = document.getElementById('usersList');
        const currentUsername = document.getElementById('currentUsername');
        const userInitial = document.getElementById('userInitial');
        const typingIndicator = document.getElementById('typingIndicator');
        const typingText = document.getElementById('typingText');

        // File upload elements
        const fileModal = document.getElementById('fileModal');
        const attachButton = document.getElementById('attachButton');
        const fileInput = document.getElementById('fileInput');
        const filePreview = document.getElementById('filePreview');
        const fileName = document.getElementById('fileName');
        const fileSize = document.getElementById('fileSize');
        const cancelUpload = document.getElementById('cancelUpload');
        const confirmUpload = document.getElementById('confirmUpload');

        // Call elements
        const callModal = document.getElementById('callModal');
        const callButton = document.getElementById('callButton');
        const callTitle = document.getElementById('callTitle');
        const callDescription = document.getElementById('callDescription');
        const callButtons = document.getElementById('callButtons');
        const callInProgress = document.getElementById('callInProgress');
        const acceptCall = document.getElementById('acceptCall');
        const rejectCall = document.getElementById('rejectCall');
        const endCall = document.getElementById('endCall');
        const localAudio = document.getElementById('localAudio');
        const remoteAudio = document.getElementById('remoteAudio');
        const incomingRingtone = document.getElementById('incomingRingtone');
        const outgoingRingtone = document.getElementById('outgoingRingtone');
        const micStatus = document.getElementById('micStatus');

        // WebRTC configuration with improved settings
        const rtcConfiguration = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' },
                { urls: 'stun:stun3.l.google.com:19302' },
                { urls: 'stun:stun4.l.google.com:19302' }
            ],
            iceCandidatePoolSize: 10,
            iceTransportPolicy: 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require'
        };

        // Audio management functions
        function playIncomingRingtone() {
            if (!ringtonePlaying) {
                console.log('Playing incoming ringtone');
                ringtonePlaying = true;
                incomingRingtone.currentTime = 0;
                incomingRingtone.play().catch(e => console.log('Could not play incoming ringtone:', e));
            }
        }

        function playOutgoingRingtone() {
            if (!ringtonePlaying) {
                console.log('Playing outgoing ringtone');
                ringtonePlaying = true;
                outgoingRingtone.currentTime = 0;
                outgoingRingtone.play().catch(e => console.log('Could not play outgoing ringtone:', e));
            }
        }

        function stopRingtones() {
            console.log('Stopping all ringtones');
            ringtonePlaying = false;
            incomingRingtone.pause();
            incomingRingtone.currentTime = 0;
            outgoingRingtone.pause();
            outgoingRingtone.currentTime = 0;
        }

        function setCallState(newState) {
            console.log(`Call state changing from ${callState} to ${newState}`);
            callState = newState;

            if (newState === 'idle') {
                stopRingtones();
            }
        }

        // Handle username submission - REQUEST MICROPHONE IMMEDIATELY
        usernameForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            console.log('Username form submitted');
            const username = usernameInput.value.trim();
            console.log('Username entered:', username);

            if (username) {
                try {
                    // Request microphone permission immediately when joining
                    console.log('Requesting microphone permission...');
                    localStream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true
                        }
                    });
                    localAudio.srcObject = localStream;
                    localAudio.muted = true; // Always mute local audio to prevent feedback

                    // Update microphone status indicator
                    micStatus.className = 'w-2 h-2 bg-green-500 rounded-full animate-pulse';
                    micStatus.title = 'Microphone ready';

                    console.log('âœ… Microphone access granted');

                    // Set user info and show chat
                    currentUser = username;
                    currentUsername.textContent = username;
                    userInitial.textContent = username.charAt(0).toUpperCase();

                    console.log('Hiding username modal, showing chat');
                    usernameModal.classList.add('hidden');
                    chatContainer.classList.remove('hidden');

                    console.log('Emitting user-joined event');
                    socket.emit('user-joined', username);
                    messageInput.focus();

                } catch (error) {
                    console.error('Microphone permission denied:', error);

                    let errorMessage = 'Microphone access is required for voice calls. ';
                    if (error.name === 'NotAllowedError') {
                        errorMessage += 'Please allow microphone access and refresh the page.';
                    } else {
                        errorMessage += 'Please check your microphone settings and refresh the page.';
                    }

                    alert(errorMessage);
                    // Allow chat without microphone but disable call features
                    currentUser = username;
                    currentUsername.textContent = username;
                    userInitial.textContent = username.charAt(0).toUpperCase();

                    usernameModal.classList.add('hidden');
                    chatContainer.classList.remove('hidden');
                    socket.emit('user-joined', username);
                    messageInput.focus();

                    // Disable call button and update mic status
                    callButton.disabled = true;
                    callButton.title = 'Microphone access required for calls';
                    micStatus.className = 'w-2 h-2 bg-red-500 rounded-full';
                    micStatus.title = 'Microphone not available';
                }
            } else {
                console.log('No username entered');
                alert('Please enter a username');
            }
        });

        // Handle message submission
        messageForm.addEventListener('submit', (e) => {
            e.preventDefault();
            const message = messageInput.value.trim();
            if (message) {
                socket.emit('send-message', { message });
                messageInput.value = '';
                socket.emit('typing', false);
            }
        });

        // Handle typing indicator
        messageInput.addEventListener('input', () => {
            socket.emit('typing', true);
            clearTimeout(typingTimer);
            typingTimer = setTimeout(() => {
                socket.emit('typing', false);
            }, 1000);
        });

        // File upload handlers
        attachButton.addEventListener('click', () => {
            fileModal.classList.remove('hidden');
        });

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                selectedFile = file;
                fileName.textContent = file.name;
                fileSize.textContent = formatFileSize(file.size);
                filePreview.classList.remove('hidden');
                confirmUpload.disabled = false;
            }
        });

        cancelUpload.addEventListener('click', () => {
            fileModal.classList.add('hidden');
            selectedFile = null;
            fileInput.value = '';
            filePreview.classList.add('hidden');
            confirmUpload.disabled = true;
        });

        confirmUpload.addEventListener('click', async () => {
            if (selectedFile) {
                const formData = new FormData();
                formData.append('file', selectedFile);

                try {
                    const response = await fetch('/upload', {
                        method: 'POST',
                        body: formData
                    });

                    if (response.ok) {
                        const fileData = await response.json();

                        socket.emit('send-file', {
                            fileName: fileData.originalName,
                            fileUrl: fileData.url,
                            fileSize: fileData.size,
                            fileType: fileData.mimetype
                        });

                        fileModal.classList.add('hidden');
                        selectedFile = null;
                        fileInput.value = '';
                        filePreview.classList.add('hidden');
                        confirmUpload.disabled = true;
                    }
                } catch (error) {
                    console.error('Upload failed:', error);
                    alert('Failed to upload file. Please try again.');
                }
            }
        });

        // Call handlers
        callButton.addEventListener('click', () => {
            if (connectedUsers.length > 1) {
                showUserSelectionForCall();
            } else {
                alert('No other users available to call');
            }
        });

        // SIMPLIFIED ACCEPT CALL - NO MICROPHONE REQUEST
        acceptCall.addEventListener('click', () => {
            console.log('Accept call clicked');

            if (!currentCallId || callState !== 'ringing') {
                console.log('No valid call to accept');
                return;
            }

            if (!localStream) {
                alert('Microphone not available. Please refresh the page and allow microphone access.');
                socket.emit('call-response', { callId: currentCallId, accepted: false });
                endCurrentCall();
                hideCallModal();
                return;
            }

            console.log('âœ… Microphone ready, accepting call...');
            stopRingtones();
            setCallState('connecting');

            // Accept the call
            socket.emit('call-response', { callId: currentCallId, accepted: true });

            // Update UI
            callTitle.textContent = 'Connecting...';
            callDescription.textContent = 'Setting up call...';
            callButtons.classList.add('hidden');
            callInProgress.classList.remove('hidden');
        });

        rejectCall.addEventListener('click', () => {
            if (currentCallId && callState === 'ringing') {
                console.log('Rejecting call');
                socket.emit('call-response', { callId: currentCallId, accepted: false });
                endCurrentCall();
                hideCallModal();
            }
        });

        endCall.addEventListener('click', () => {
            console.log('Ending call');
            socket.emit('end-call');
            endCurrentCall();
            hideCallModal();
        });

        // Socket event listeners
        socket.on('receive-message', (data) => {
            addMessage(data);
        });

        socket.on('user-connected', (data) => {
            addSystemMessage(data.message, 'joined');
        });

        socket.on('user-disconnected', (data) => {
            addSystemMessage(data.message, 'left');
        });

        socket.on('users-update', (users) => {
            updateUsersList(users);
        });

        socket.on('user-typing', (data) => {
            if (data.isTyping) {
                typingText.textContent = `${data.username} is typing...`;
                typingIndicator.classList.remove('hidden');
            } else {
                typingIndicator.classList.add('hidden');
            }
        });

        // Call event listeners
        socket.on('incoming-call', (data) => {
            console.log('Incoming call from:', data.callerUsername);

            if (callState !== 'idle') {
                console.log('Already in a call, rejecting incoming call');
                socket.emit('call-response', { callId: data.callId, accepted: false });
                return;
            }

            currentCallId = data.callId;
            setCallState('ringing');

            callTitle.textContent = 'Incoming Call';
            callDescription.textContent = `${data.callerUsername} is calling you...`;
            callButtons.classList.remove('hidden');
            callInProgress.classList.add('hidden');
            callModal.classList.remove('hidden');

            playIncomingRingtone();
        });

        socket.on('call-ringing', (data) => {
            console.log('Call is ringing for:', data.targetUsername);

            if (callState === 'idle') {
                setCallState('ringing');
                currentCallId = data.callId;

                callTitle.textContent = 'Calling...';
                callDescription.textContent = `Calling ${data.targetUsername}...`;
                callButtons.classList.add('hidden');
                callInProgress.classList.remove('hidden');
                callModal.classList.remove('hidden');

                playOutgoingRingtone();
            }
        });

        socket.on('call-accepted', (data) => {
            console.log('Call was accepted by remote user');

            stopRingtones();
            setCallState('connecting');

            callTitle.textContent = 'Connecting...';
            callDescription.textContent = 'Setting up call...';
            callButtons.classList.add('hidden');
            callInProgress.classList.remove('hidden');
        });

        socket.on('call-rejected', (data) => {
            console.log('Call was rejected');
            endCurrentCall();
            hideCallModal();
            alert('Call was declined');
        });

        socket.on('call-busy', (data) => {
            console.log('User is busy');
            endCurrentCall();
            hideCallModal();
            alert(`${data.targetUsername || 'User'} is busy`);
        });

        socket.on('call-timeout', () => {
            console.log('Call timed out');
            endCurrentCall();
            hideCallModal();
            alert('Call timed out - no answer');
        });

        socket.on('call-error', (data) => {
            console.log('Call error:', data.message);
            endCurrentCall();
            hideCallModal();
            alert(`Call failed: ${data.message}`);
        });

        socket.on('call-ended', (data) => {
            console.log('Call ended by remote user');

            if (data && data.reason) {
                console.log('Call end reason:', data.reason);
                if (data.reason === 'User disconnected') {
                    alert(`Call ended: ${data.disconnectedUser} disconnected`);
                }
            }

            endCurrentCall();
            hideCallModal();
        });

        socket.on('start-webrtc-caller', (data) => {
            console.log('Starting as WebRTC caller with peer:', data.peerId);
            startWebRTCCaller(data.peerId);
        });

        socket.on('start-webrtc-receiver', (data) => {
            console.log('Starting as WebRTC receiver, waiting for offer from:', data.peerId);
            currentPeerId = data.peerId;
            setupWebRTCReceiver();
        });

        // WebRTC event listeners
        socket.on('webrtc-offer', async (data) => {
            await handleOffer(data.offer, data.senderId);
        });

        socket.on('webrtc-answer', async (data) => {
            await handleAnswer(data.answer);
        });

        socket.on('webrtc-ice-candidate', async (data) => {
            await handleIceCandidate(data.candidate);
        });

        // Helper functions
        function addMessage(data) {
            const isOwnMessage = data.userId === socket.id;
            const messageDiv = document.createElement('div');
            messageDiv.className = `flex ${isOwnMessage ? 'justify-end' : 'justify-start'} animate-fade-in`;

            const time = new Date(data.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

            let messageContent = '';

            if (data.type === 'file') {
                const isImage = data.fileData.type.startsWith('image/');
                if (isImage) {
                    messageContent = `
                        <div class="mb-2">
                            <img src="${data.fileData.url}" alt="${data.fileData.name}" class="max-w-xs lg:max-w-sm rounded-lg cursor-pointer" onclick="window.open('${data.fileData.url}', '_blank')">
                        </div>
                        <div class="text-xs lg:text-sm">${escapeHtml(data.fileData.name)}</div>
                    `;
                } else {
                    messageContent = `
                        <div class="flex items-center bg-gray-100 rounded-lg p-2 lg:p-3 mb-2">
                            <svg class="w-5 h-5 lg:w-6 lg:h-6 text-blue-500 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                            </svg>
                            <div>
                                <div class="font-medium text-gray-800 text-xs lg:text-sm">${escapeHtml(data.fileData.name)}</div>
                                <div class="text-xs text-gray-500">${formatFileSize(data.fileData.size)}</div>
                            </div>
                        </div>
                        <a href="${data.fileData.url}" target="_blank" class="text-blue-500 hover:underline text-xs lg:text-sm">Download</a>
                    `;
                }
            } else {
                messageContent = `<div class="break-words text-sm lg:text-base">${escapeHtml(data.message)}</div>`;
            }

            messageDiv.innerHTML = `
                <div class="max-w-xs lg:max-w-md ${isOwnMessage ? 'order-1' : 'order-2'}">
                    <div class="${isOwnMessage ? 'bg-gradient-to-r from-blue-500 to-purple-600 text-white' : 'bg-white text-gray-800 border border-gray-200'} rounded-2xl px-3 lg:px-4 py-2 lg:py-3 shadow-sm">
                        ${!isOwnMessage ? `<div class="text-xs font-semibold ${isOwnMessage ? 'text-blue-100' : 'text-gray-500'} mb-1">${data.username}</div>` : ''}
                        ${messageContent}
                        <div class="text-xs ${isOwnMessage ? 'text-blue-100' : 'text-gray-400'} mt-1">${time}</div>
                    </div>
                </div>
                ${!isOwnMessage ? `
                <div class="w-6 h-6 lg:w-8 lg:h-8 bg-gradient-to-r from-green-400 to-blue-500 rounded-full flex items-center justify-center mr-2 lg:mr-3 order-1 flex-shrink-0">
                    <span class="text-white text-xs lg:text-sm font-semibold">${data.username.charAt(0).toUpperCase()}</span>
                </div>
                ` : ''}
            `;

            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        function addSystemMessage(message, type) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'flex justify-center animate-fade-in';

            const bgColor = type === 'joined' ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800';

            messageDiv.innerHTML = `
                <div class="px-4 py-2 rounded-full text-sm ${bgColor}">
                    ${escapeHtml(message)}
                </div>
            `;

            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        function updateUsersList(users) {
            usersList.innerHTML = '';
            connectedUsers = users;

            users.forEach(user => {
                const isCurrentUser = user.id === socket.id;
                const userDiv = document.createElement('div');
                userDiv.className = 'flex items-center py-2 px-2 lg:px-3 rounded-lg hover:bg-gray-800 transition-colors duration-200';

                const callButtonHtml = !isCurrentUser ?
                    `<button onclick="initiateCall('${user.id}')" class="ml-auto p-1 text-green-400 hover:text-green-300 transition-colors duration-200" title="Call ${user.username}">
                        <svg class="w-3 h-3 lg:w-4 lg:h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 5a2 2 0 012-2h3.28a1 1 0 01.948.684l1.498 4.493a1 1 0 01-.502 1.21l-2.257 1.13a11.042 11.042 0 005.516 5.516l1.13-2.257a1 1 0 011.21-.502l4.493 1.498a1 1 0 01.684.949V19a2 2 0 01-2 2h-1C9.716 21 3 14.284 3 6V5z"></path>
                        </svg>
                    </button>` : '';

                userDiv.innerHTML = `
                    <div class="w-6 h-6 lg:w-8 lg:h-8 bg-gradient-to-r from-green-400 to-blue-500 rounded-full flex items-center justify-center mr-2 lg:mr-3">
                        <span class="text-white text-xs lg:text-sm font-semibold">${user.username.charAt(0).toUpperCase()}</span>
                    </div>
                    <div class="flex-1 min-w-0">
                        <div class="font-medium text-xs lg:text-sm truncate">${escapeHtml(user.username)} ${isCurrentUser ? '(You)' : ''}</div>
                        <div class="text-xs text-green-400">Online</div>
                    </div>
                    ${callButtonHtml}
                `;
                usersList.appendChild(userDiv);
            });
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        function escapeHtml(unsafe) {
            return unsafe
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }

        // SIMPLIFIED CALL INITIATION - NO MICROPHONE REQUEST
        function initiateCall(targetUserId) {
            console.log('Initiating call to:', targetUserId);

            if (callState !== 'idle') {
                alert('You are already in a call');
                return;
            }

            if (!localStream) {
                alert('Microphone not available. Please refresh the page and allow microphone access.');
                return;
            }

            console.log('âœ… Microphone ready, starting call...');
            setCallState('connecting');

            // Show call UI immediately
            callTitle.textContent = 'Calling...';
            callDescription.textContent = 'Waiting for response...';
            callButtons.classList.add('hidden');
            callInProgress.classList.remove('hidden');
            callModal.classList.remove('hidden');

            // Emit call initiation
            socket.emit('initiate-call', targetUserId);
        }

        function showUserSelectionForCall() {
            const otherUsers = connectedUsers.filter(user => user.id !== socket.id);
            if (otherUsers.length === 0) {
                alert('No other users available to call');
                return;
            }

            initiateCall(otherUsers[0].id);
        }

        // Call functions with proper WebRTC flow
        async function startWebRTCCaller(peerId) {
            console.log('ðŸ”„ Setting up WebRTC as caller for peer:', peerId);

            try {
                // Clean up existing connection
                if (peerConnection) {
                    console.log('Closing existing peer connection');
                    peerConnection.close();
                }

                // Create new peer connection
                peerConnection = new RTCPeerConnection(rtcConfiguration);
                setupPeerConnectionHandlers(peerId);

                if (!localStream) {
                    console.error('âŒ No local stream available for caller');
                    throw new Error('Microphone not available');
                }

                console.log('âœ… Local stream available, adding tracks...');

                // Add all local tracks to peer connection
                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                    console.log('âœ… Caller added local track:', track.kind);
                });

                // Create offer with robust constraints
                console.log('ðŸ“ž Creating WebRTC offer...');
                const offer = await peerConnection.createOffer({
                    offerToReceiveAudio: true,
                    voiceActivityDetection: true,
                    iceRestart: false
                });

                await peerConnection.setLocalDescription(offer);
                console.log('âœ… Caller set local description (offer)');

                // Send offer to peer
                socket.emit('webrtc-offer', {
                    offer: offer,
                    targetId: peerId
                });

                console.log('ðŸ“¤ Offer sent to peer:', peerId);

            } catch (error) {
                console.error('âŒ Error in startWebRTCCaller:', error);
                callDescription.textContent = 'Failed to start call';
                setTimeout(() => {
                    endCurrentCall();
                    hideCallModal();
                    alert('Failed to start call: ' + error.message);
                }, 2000);
            }
        }

        function setupWebRTCReceiver() {
            console.log('ðŸ“± Setting up WebRTC as receiver');

            if (!localStream) {
                console.error('âŒ No local stream available for receiver');
                callDescription.textContent = 'Microphone not available';
                setTimeout(() => {
                    endCurrentCall();
                    hideCallModal();
                    alert('Microphone not available. Please refresh and allow access.');
                }, 2000);
                return;
            }

            console.log('âœ… Receiver ready with microphone, waiting for offer...');
        }

        function setupPeerConnectionHandlers(peerId) {
            // Handle incoming tracks (remote audio)
            peerConnection.ontrack = (event) => {
                console.log('ðŸŽµ Received remote audio track from peer');
                console.log('Remote stream details:', event.streams[0]);

                remoteStream = event.streams[0];
                remoteAudio.srcObject = remoteStream;

                // Set call state to connected when we receive audio
                setCallState('connected');
                callTitle.textContent = 'Call Connected';
                callDescription.textContent = 'You can now talk!';

                // Ensure remote audio plays - critical for hearing the other person
                remoteAudio.volume = 1.0; // Max volume
                remoteAudio.autoplay = true;

                // Force audio to play
                const playRemoteAudio = () => {
                    remoteAudio.play().then(() => {
                        console.log('âœ… Remote audio playing successfully - you can now hear the other person!');
                    }).catch(e => {
                        console.log('âš ï¸ Auto-play prevented - user interaction required');
                        callDescription.textContent = 'Call connected - click anywhere to enable audio';

                        // Add one-time click handler to enable audio
                        const enableAudio = () => {
                            remoteAudio.play().then(() => {
                                console.log('âœ… Audio enabled - you can now hear the other person!');
                                callDescription.textContent = 'You can now talk!';
                            }).catch(err => {
                                console.error('Failed to enable audio:', err);
                            });
                        };
                        document.addEventListener('click', enableAudio, { once: true });
                    });
                };

                // Try to play immediately and also when metadata loads
                playRemoteAudio();
                remoteAudio.addEventListener('loadedmetadata', playRemoteAudio, { once: true });
            };

            // Handle ICE candidates with better logging
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    console.log('ICE candidate found:', event.candidate.type, event.candidate.protocol);
                    socket.emit('webrtc-ice-candidate', {
                        candidate: event.candidate,
                        targetId: peerId
                    });
                } else {
                    console.log('All ICE candidates gathered - ICE gathering complete');
                }
            };

            // Monitor connection state
            peerConnection.onconnectionstatechange = () => {
                const state = peerConnection.connectionState;
                console.log('WebRTC connection state changed:', state);

                switch (state) {
                    case 'connecting':
                        callDescription.textContent = 'Connecting...';
                        break;
                    case 'connected':
                        console.log('ðŸŽ‰ WebRTC connection established successfully!');
                        setCallState('connected');
                        callTitle.textContent = 'Call Connected';
                        callDescription.textContent = 'You can now talk!';
                        break;
                    case 'disconnected':
                        console.log('WebRTC connection disconnected');
                        callDescription.textContent = 'Connection lost...';
                        break;
                    case 'failed':
                        console.log('âŒ WebRTC connection failed');
                        callDescription.textContent = 'Connection failed';
                        setTimeout(() => {
                            endCurrentCall();
                            hideCallModal();
                            alert('Call connection failed. Please try again.');
                        }, 3000);
                        break;
                    case 'closed':
                        console.log('WebRTC connection closed');
                        break;
                }
            };

            // Monitor ICE connection state
            peerConnection.oniceconnectionstatechange = () => {
                const iceState = peerConnection.iceConnectionState;
                console.log('ICE connection state:', iceState);

                switch (iceState) {
                    case 'checking':
                        console.log('ICE checking...');
                        callDescription.textContent = 'Establishing connection...';
                        break;
                    case 'connected':
                    case 'completed':
                        console.log('ðŸŽ‰ ICE connection successful!');
                        setCallState('connected');
                        callTitle.textContent = 'Call Connected';
                        callDescription.textContent = 'You can now talk!';
                        break;
                    case 'disconnected':
                        console.log('ICE disconnected - attempting to reconnect...');
                        callDescription.textContent = 'Connection interrupted - reconnecting...';
                        // Give it time to reconnect
                        setTimeout(() => {
                            if (peerConnection && peerConnection.iceConnectionState === 'disconnected') {
                                console.log('Could not reconnect');
                                endCurrentCall();
                                hideCallModal();
                                alert('Call disconnected. Please try again.');
                            }
                        }, 5000);
                        break;
                    case 'failed':
                        console.log('âŒ ICE connection failed');
                        callDescription.textContent = 'Connection failed';
                        setTimeout(() => {
                            endCurrentCall();
                            hideCallModal();
                            alert('Call connection failed. Please check your network and try again.');
                        }, 2000);
                        break;
                }
            };

            // Monitor ICE gathering state
            peerConnection.onicegatheringstatechange = () => {
                console.log('ICE gathering state:', peerConnection.iceGatheringState);
            };

            // Handle data channel errors
            peerConnection.onerror = (error) => {
                console.error('WebRTC error:', error);
                callDescription.textContent = 'Connection error occurred';
            };
        }

        async function handleOffer(offer, senderId) {
            console.log('ðŸ“¥ Handling WebRTC offer from:', senderId);

            try {
                // Create new peer connection if needed
                if (!peerConnection) {
                    peerConnection = new RTCPeerConnection(rtcConfiguration);
                    setupPeerConnectionHandlers(senderId);
                }

                // Verify we have local stream
                if (!localStream) {
                    console.error('âŒ No local stream available to handle offer');
                    throw new Error('Microphone not available');
                }

                console.log('âœ… Local stream available, adding tracks to peer connection...');

                // Add local tracks to peer connection
                localStream.getTracks().forEach(track => {
                    const sender = peerConnection.getSenders().find(s => s.track && s.track.kind === track.kind);
                    if (!sender) {
                        peerConnection.addTrack(track, localStream);
                        console.log('âœ… Receiver added local track:', track.kind);
                    }
                });

                // Set remote description (the offer)
                await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
                console.log('âœ… Set remote description (offer)');

                // Create and set local description (the answer)
                console.log('ðŸ“ž Creating WebRTC answer...');
                const answer = await peerConnection.createAnswer({
                    offerToReceiveAudio: true,
                    voiceActivityDetection: true
                });

                await peerConnection.setLocalDescription(answer);
                console.log('âœ… Created and set local description (answer)');

                // Send answer back to caller
                socket.emit('webrtc-answer', {
                    answer: answer,
                    targetId: senderId
                });

                console.log('ðŸ“¤ Answer sent to:', senderId);

            } catch (error) {
                console.error('âŒ Error handling offer:', error);
                callDescription.textContent = 'Failed to process call';
                setTimeout(() => {
                    endCurrentCall();
                    hideCallModal();
                    alert('Failed to process call: ' + error.message);
                }, 2000);
            }
        }

        async function handleAnswer(answer) {
            console.log('Handling WebRTC answer');

            if (!peerConnection) {
                console.error('No peer connection available to handle answer');
                return;
            }

            try {
                await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
                console.log('Remote description (answer) set successfully');
            } catch (error) {
                console.error('Error handling answer:', error);
                callDescription.textContent = 'Failed to establish connection';
            }
        }

        async function handleIceCandidate(candidate) {
            console.log('Handling ICE candidate');

            if (!peerConnection) {
                console.error('No peer connection available for ICE candidate');
                return;
            }

            try {
                await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                console.log('ICE candidate added successfully');
            } catch (error) {
                console.error('Error adding ICE candidate:', error);
                // Don't fail the call for ICE candidate errors, just log them
            }
        }

        function endCurrentCall() {
            console.log('Ending current call');

            // Stop ringtones
            stopRingtones();

            // Set state to idle
            setCallState('idle');

            // IMPORTANT: Don't stop local stream - keep microphone ready for next call
            // We only stop the stream when the user leaves the chat completely

            // Close peer connection
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
                console.log('Peer connection closed');
            }

            // Clear remote stream
            if (remoteStream) {
                remoteAudio.srcObject = null;
                remoteStream = null;
            }

            // Reset call variables
            currentCallId = null;
            currentPeerId = null;

            console.log('Call cleanup completed - microphone still ready');
        }

        function hideCallModal() {
            callModal.classList.add('hidden');
        }

        // Focus username input on load
        usernameInput.focus();

        // Clean up microphone when leaving the page
        window.addEventListener('beforeunload', () => {
            if (localStream) {
                localStream.getTracks().forEach(track => {
                    track.stop();
                });
            }
        });
    </script>
</body>
</html>